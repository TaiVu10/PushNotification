import { io } from 'socket.io-client';
import { getCsrfTokenHeadersForEndpointRequest } from './CsrfUtils';
export var State;
(function (State) {
    State["ACTIVE"] = "active";
    State["INACTIVE"] = "inactive";
})(State || (State = {}));
/**
 * A representation of the underlying persistent network connection used for subscribing to Flux type endpoint methods.
 */
export class FluxConnection extends EventTarget {
    constructor() {
        var _a, _b;
        super();
        Object.defineProperty(this, "nextId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "endpointInfos", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "onNextCallbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "onCompleteCallbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "onErrorCallbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "socket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: State.INACTIVE
        });
        if (!((_b = (_a = window.Vaadin) === null || _a === void 0 ? void 0 : _a.featureFlags) === null || _b === void 0 ? void 0 : _b.hillaPush)) {
            // Remove when removing feature flag
            throw new Error(`Push support in Hilla is not enabled. Enable it in the debug window or by adding com.vaadin.experimental.hillaPush=true to vaadin-featureflags.properties`);
        }
        this.connectWebsocket();
    }
    connectWebsocket() {
        const extraHeaders = getCsrfTokenHeadersForEndpointRequest(document);
        this.socket = io('/hilla', { path: '/HILLA/push', extraHeaders });
        this.socket.on('message', (message) => {
            this.handleMessage(JSON.parse(message));
        });
        this.socket.on('disconnect', () => {
            // https://socket.io/docs/v4/client-api/#event-disconnect
            if (this.state === State.ACTIVE) {
                this.state = State.INACTIVE;
                this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: false } }));
            }
        });
        this.socket.on('connect_error', () => {
            // https://socket.io/docs/v4/client-api/#event-connect_error
        });
        this.socket.on('connect', () => {
            // https://socket.io/docs/v4/client-api/#event-connect
            if (this.state === State.INACTIVE) {
                this.state = State.ACTIVE;
                this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: true } }));
            }
        });
    }
    handleMessage(message) {
        const { id } = message;
        const endpointInfo = this.endpointInfos.get(id);
        if (message['@type'] === 'update') {
            const callback = this.onNextCallbacks.get(id);
            if (callback) {
                callback(message.item);
            }
        }
        else if (message['@type'] === 'complete') {
            const callback = this.onCompleteCallbacks.get(id);
            if (callback) {
                callback();
            }
            this.removeSubscription(id);
        }
        else if (message['@type'] === 'error') {
            const callback = this.onErrorCallbacks.get(id);
            if (callback) {
                callback();
            }
            this.removeSubscription(id);
            if (!callback) {
                throw new Error(`Error in ${endpointInfo}: ${message.message}`);
            }
        }
        else {
            throw new Error(`Unknown message from server: ${message}`);
        }
    }
    removeSubscription(id) {
        this.onNextCallbacks.delete(id);
        this.onCompleteCallbacks.delete(id);
        this.onErrorCallbacks.delete(id);
        this.endpointInfos.delete(id);
    }
    send(message) {
        this.socket.send(message);
    }
    /**
     * Subscribes to the flux returned by the given endpoint name + method name using the given parameters.
     *
     * @param endpointName the endpoint to connect to
     * @param methodName the method in the endpoint to connect to
     * @param parameters the parameters to use
     * @returns a subscription
     */
    subscribe(endpointName, methodName, parameters) {
        const id = this.nextId.toString();
        this.nextId += 1;
        const params = parameters || [];
        const msg = { '@type': 'subscribe', id, endpointName, methodName, params };
        const endpointInfo = `${endpointName}.${methodName}(${JSON.stringify(params)})`;
        this.send(msg);
        this.endpointInfos.set(id, endpointInfo);
        const hillaSubscription = {
            onNext: (callback) => {
                this.onNextCallbacks.set(id, callback);
                return hillaSubscription;
            },
            onComplete: (callback) => {
                this.onCompleteCallbacks.set(id, callback);
                return hillaSubscription;
            },
            onError: (callback) => {
                this.onErrorCallbacks.set(id, callback);
                return hillaSubscription;
            },
            cancel: () => {
                if (!this.endpointInfos.has(id)) {
                    // Subscription already closed or canceled
                    return;
                }
                const closeMessage = { '@type': 'unsubscribe', id };
                this.send(closeMessage);
                this.removeSubscription(id);
            },
            context: (context) => {
                context.addController({
                    hostDisconnected: () => {
                        hillaSubscription.cancel();
                    },
                });
                return hillaSubscription;
            },
        };
        return hillaSubscription;
    }
}
//# sourceMappingURL=FluxConnection.js.map